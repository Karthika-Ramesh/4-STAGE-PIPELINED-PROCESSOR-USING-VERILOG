//====================================================
// 4-Stage Pipelined Processor
// Stages: IF -> ID -> EX -> WB
// Instructions: ADD, SUB, LOAD
//====================================================

module cpu4stage (
    input clk,
    input reset
);

    // -----------------------------
    // Instruction format (8-bit)
    // [7:6] Opcode
    // [5:3] Rd
    // [2:0] Rs
    // -----------------------------

    // Opcodes
    parameter ADD  = 2'b00;
    parameter SUB  = 2'b01;
    parameter LOAD = 2'b10;
    parameter NOP  = 2'b11;

    // Program Counter
    reg [3:0] pc;

    // Instruction Memory (16 x 8)
    reg [7:0] instr_mem [0:15];

    // Register File (8 x 8)
    reg [7:0] reg_file [0:7];

    // Data Memory (16 x 8)
    reg [7:0] data_mem [0:15];

    // Pipeline Registers
    reg [7:0] IF_ID_instr;
    reg [7:0] ID_EX_instr;
    reg [7:0] EX_WB_result;
    reg [2:0] EX_WB_rd;

    integer i;

    // -----------------------------
    // Instruction Fetch (IF)
    // -----------------------------
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            pc <= 0;
            IF_ID_instr <= 8'b0;
        end else begin
            IF_ID_instr <= instr_mem[pc];
            pc <= pc + 1;
        end
    end

    // -----------------------------
    // Instruction Decode (ID)
    // -----------------------------
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ID_EX_instr <= 8'b0;
        end else begin
            ID_EX_instr <= IF_ID_instr;
        end
    end

    // -----------------------------
    // Execute (EX)
    // -----------------------------
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            EX_WB_result <= 0;
            EX_WB_rd <= 0;
        end else begin
            case (ID_EX_instr[7:6])
                ADD: begin
                    EX_WB_result <= reg_file[ID_EX_instr[5:3]] +
                                    reg_file[ID_EX_instr[2:0]];
                    EX_WB_rd <= ID_EX_instr[5:3];
                end

                SUB: begin
                    EX_WB_result <= reg_file[ID_EX_instr[5:3]] -
                                    reg_file[ID_EX_instr[2:0]];
                    EX_WB_rd <= ID_EX_instr[5:3];
                end

                LOAD: begin
                    EX_WB_result <= data_mem[ID_EX_instr[2:0]];
                    EX_WB_rd <= ID_EX_instr[5:3];
                end

                default: begin
                    EX_WB_result <= 0;
                    EX_WB_rd <= 0;
                end
            endcase
        end
    end

    // -----------------------------
    // Write Back (WB)
    // -----------------------------
    always @(posedge clk or posedge reset) begin
        if (!reset) begin
            reg_file[EX_WB_rd] <= EX_WB_result;
        end
    end

    // -----------------------------
    // Initial Program & Data
    // -----------------------------
    initial begin
        // Initialize registers
        for (i = 0; i < 8; i = i + 1)
            reg_file[i] = 0;

        // Initialize data memory
        data_mem[0] = 8'd10;
        data_mem[1] = 8'd5;

        // Instruction Program
        instr_mem[0] = {LOAD, 3'b001, 3'b000}; // LOAD R1, mem[0]
        instr_mem[1] = {LOAD, 3'b010, 3'b001}; // LOAD R2, mem[1]
        instr_mem[2] = {ADD,  3'b011, 3'b010}; // ADD  R3 = R3 + R2
        instr_mem[3] = {SUB,  3'b100, 3'b001}; // SUB  R4 = R4 - R1
        instr_mem[4] = {NOP,  6'b000000};
    end

endmodule
